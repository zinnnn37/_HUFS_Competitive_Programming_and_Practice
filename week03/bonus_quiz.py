'''
A[i] +- 1은 점수 아님
A[i]만큼만 점수
3
1 2 3
>> 큰 값부터 뽑으면 좋을 것
>> 가장 큰 값부터 뽑는다면 그것보다 더 큰 값이 없으므로
적은 수를 지울 수 있음 
-> 정렬 ?
>> [n][2] 크기의 이차원 배열을 생성해서
0일 때는 지우지 않았을 때 1일 때는 지웠을 때의 점수

max가 여러개 있으면 max * n만큼의 점수를 얻을 수 있음
그런데 max-1이 엄청 많으면 어떡해
그리디 + dp해야하나

현재 최대값 = k
DP[k] = 1, 2, ..., k 중에서 최선의 점수
1. k를 선택한 경우: k * count(k) + max(DP[k-2], DP[k-3], ..., DP[1]) # DP[k-1]은 삭제되므로
2. k를 선택하지 않은 경우 = DP[k-1]

-> 단점: pseudo time algorithm >> O(max * n)이 됨..
사실 DP 테이블을 만들 필요가 없디 ?
아니 그니까 max(...) 하는 게 아니라 DP[k-2]가 맞다는 소리 아닌가
'''