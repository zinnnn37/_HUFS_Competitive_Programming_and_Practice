'''
n개의 선물 가격이 주어졌을 때, b의 예산으로 최대로 많은 선물을 사려고 한다.
이때, 최대 a개의 선물에 대해서는 반값 할인을 받을 수 있다고 했을 때
최대로 살 수 있는 선물의 수를 구하는 프로그램을 작성하시오.
단, 한 선물에는 최대 한 번만 반값 할인을 받을 수 있다.

입력:
	첫 번째 줄에 선물의 개수를 나타내는 양의 정수 n(1 <= n <= 100,000),
	예산을 나타내는 양의 정수 b(1 <= b <= 10^9),
	반값 할인을 받을 수 있는 최대 선물의 수를 나타내는
	정수 a(0 <= a <= n)가 차례대로 주어진다.
	다음 줄에 n개의 선물 가격이 공백을 사이에 두고 주어진다.
	선물 가격은 2 이상 10억 이하의 값이며, 항상 짝수로 주어진다.

출력:
	조건을 만족하며 최대로 살 수 있는 선물의 수를 출력한다

주석:
	알고리즘을 간략히 설명하고 수행시간을 분석하시오
'''

import sys
input = lambda: sys.stdin.readline().rstrip()

def sol(n, b, a):
	sum = 0
	for i in range(a):
	# 할인을 받을 수 있는 만큼 저렴한 선물부터 구매
		sum += (price[i] // 2)
		if sum > b:
		# 전부 할인을 받아도 예산을 초과하면 인덱스 반환
		# 인덱스는 0부터 시작하므로 그냥 반환하면 된다
			return i
		'''
		인덱스는 0부터 시작이라 +1을 해주어야 구매한 선물의 수가 나오게 되는데,
		sum >= b의 경우, 마지막 선물을 담았을 때 예산과 같아지는 경우에
		바로 i를 반환하므로 마지막 선물을 구매하지 않은 것이 된다.
		
		선물 갯수 상관 없이 선물 가격이 모두 2이고 b == a인 경우 모두 해당
		이 외에도 할인 가능한 횟수 내에서 예산을 딱 맞게 사용할 수 있는 경우
		'''
	
	left = 0
	for right in range(a, n):
		sum += (price[left] // 2)
		sum += (price[right] // 2)
		# left(저렴한 선물), right(비싼 선물) 포인터를 두 개 설정하여
		# 기존에 할인 받았던 저렴한 선물은 원가에 구매하고
		# 새로 구매하는 비싼 선물을 할인 받을 때의 가격 계산
		if sum > b:
		# 예산을 초과하면 인덱스 반환
			return right
		left += 1
	# 전부 구매해도 예산을 초과하지 않으면 n 반환
	return n

if __name__ == '__main__':
	n, b, a = map(int, input().split())
	price = sorted(list(map(int, input().split())))
	print(sol(n, b, a))
	
	
'''
조건을 만족하며 가장 많은 선물을 구매하는 것이 요구사항이므로 그리디 알고리즘을 이용해 풀이했다.
우선 제품의 가격을 오름차순으로 정렬한 후 가장 저렴한 a개의 선물을 할인받아 구매한 가격을 구한다.
이후 left와 right 포인터를 두 개 설정하는데,
초기값은 각각 가장 저렴한 제품의 인덱스(0)와 가장 마지막에 할인 받은 제품의 다음 제품 인덱스(a)이다.
(a개 만큼 할인받을 수 있으니 right는 a부터 시작하면 된다)
두 포인터를 오른쪽으로 한 칸씩 옮기면서
기존에 할인 받은 left는 원가에, 아직 구매하지 않은 right는 반값에 구매한다.
위 연산을 진행했을 때 예산을 넘긴다면 반복문을 종료하고, 넘기지 않는다면 포인터를 한 칸 더 움직인다.
만약 모든 제품을 구입했음에도 예산이 초과되지 않는다면 제품의 수를 반환한다.

수행시간: O(n)
a만큼 반복문을 한 번 돌린 후 n-a만큼 반복문을 한 번 더 돌리므로 O(a + n - a), 즉 O(n)시간이 소요된다. 
'''
